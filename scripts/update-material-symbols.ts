import { mkdir, writeFile, readFile, stat } from "node:fs/promises";
import { writeFile as writeFileCallback } from "node:fs";
import { resolve } from "node:path";
import { fileURLToPath } from "node:url";
import { createHash } from "node:crypto";

// Raw URL to current codepoints file on master (still used for content fetch)
const CODEPOINTS_URL =
  "https://raw.githubusercontent.com/google/material-design-icons/refs/heads/master/variablefont/MaterialSymbolsOutlined%5BFILL%2CGRAD%2Copsz%2Cwght%5D.codepoints";
// GitHub API URL to query latest commit touching the variablefont directory (or entire repo master branch)
const REPO_COMMITS_API =
  "https://api.github.com/repos/google/material-design-icons/commits?path=variablefont&per_page=1";

// Base URL for the variable font directory in the upstream repo
const VARIABLE_FONT_BASE =
  "https://raw.githubusercontent.com/google/material-design-icons/refs/heads/master/variablefont";

// Styles we want to fetch fonts for
const FONT_STYLES = [
  { style: "Outlined", slug: "outlined" },
  { style: "Rounded", slug: "rounded" },
  { style: "Sharp", slug: "sharp" },
];

const GENERATED_DIR = "../packages/tailwindcss-material-symbols/src/generated";
const FONTS_DIR = "../packages/tailwindcss-material-symbols";
const META_FILE = "meta.json";

interface IconEntry {
  name: string;
  codepoint: string; // 4+ hex digits, lowercase
}

interface MetaFile {
  codepointsHash: string; // hash of codepoints file content
  commitSha?: string; // upstream repo commit (latest in variablefont path)
  updatedAt: string; // ISO timestamp
}

function sha256(data: string | Buffer): string {
  return createHash("sha256").update(data).digest("hex");
}

async function fetchCodepoints(): Promise<{ entries: IconEntry[]; raw: string; hash: string }> {
  const res = await fetch(CODEPOINTS_URL, { cache: "no-store" });
  if (!res.ok) throw new Error(`Failed to download codepoints: ${res.status} ${res.statusText}`);
  const text = await res.text();
  const hash = sha256(text);
  const entries = text
    .split(/\r?\n/) // lines
    .map((l) => l.trim())
    .filter((l) => l && !l.startsWith("#"))
    .map((l) => {
      const [name, hex] = l.split(/\s+/);
      if (!name || !hex) return null;
      return { name, codepoint: hex.toLowerCase() } satisfies IconEntry | null;
    })
    .filter((x): x is IconEntry => !!x)
    .sort((a, b) => a.name.localeCompare(b.name));
  return { entries, raw: text, hash };
}

function generateTS(entries: IconEntry[]): string {
  const lines: string[] = [];
  lines.push("/* Auto-generated by scripts/update-codepoints.ts. Do not edit manually. */");
  lines.push("// prettier-ignore");
  lines.push("export const codepoints = {");
  for (const { name, codepoint } of entries) {
    // In TS we use the full unicode escape with leading \u and zero-pad to at least 4 digits (Material hex values already 4+)
    const uni = "\\u" + codepoint.padStart(4, "0");
    lines.push(`  "${name}": "${uni}",`);
  }
  lines.push("} as const;\n");
  lines.push("export default codepoints;\n");
  return lines.join("\n");
}

function generateCSS(entries: IconEntry[]): string {
  const lines: string[] = [];
  lines.push("/* Auto-generated by scripts/update-codepoints.ts. Do not edit manually. */");
  lines.push("@theme {");
  for (const { name, codepoint } of entries) {
    // CSS expects escaped sequence inside quotes: "\e951" (no leading u, 1 backslash)
    const cssEsc = `\\${codepoint}`; // single backslash in output
    lines.push(`  --icon-symbol-${name}: "${cssEsc}";`);
  }
  lines.push("}\n");
  return lines.join("\n");
}

async function writeOutputs(entries: IconEntry[], meta: MetaFile) {
  const outDir = fileURLToPath(new URL(GENERATED_DIR, import.meta.url));
  await mkdir(outDir, { recursive: true });
  await Promise.all([
    writeFile(resolve(outDir, "codepoints.ts"), generateTS(entries), "utf8"),
    writeFile(resolve(outDir, "codepoints.css"), generateCSS(entries), "utf8"),
    writeFile(resolve(outDir, META_FILE), JSON.stringify(meta, null, 2) + "\n", "utf8"),
  ]);
}

async function fetchLatestCommitSha(): Promise<string | null> {
  try {
    const res = await fetch(REPO_COMMITS_API, {
      headers: { "User-Agent": "tailwindcss-material-symbols-update-script" },
    });
    if (!res.ok) {
      console.warn(
        `[material-symbols] Failed to fetch commit SHA (${res.status}). Continuing without commitSha.`,
      );
      return null;
    }
    const data: any = await res.json();
    if (Array.isArray(data) && data[0]?.sha) return data[0].sha as string;
    return null;
  } catch (e) {
    console.warn("[material-symbols] Error fetching commit SHA:", e);
    return null;
  }
}

function buildRemoteFontFileName(style: string): string {
  // Matches upstream naming pattern: MaterialSymbols<Style>[FILL,GRAD,opsz,wght].woff2 with encoded brackets & commas
  return `MaterialSymbols${style}%5BFILL%2CGRAD%2Copsz%2Cwght%5D.woff2`;
}

async function downloadFont(style: string, slug: string, destDir: string): Promise<void> {
  const remoteName = buildRemoteFontFileName(style);
  const url = `${VARIABLE_FONT_BASE}/${remoteName}`;
  const fileName = `material-symbols-${slug}.woff2`;
  const filePath = resolve(destDir, fileName);

  const res = await fetch(url);
  if (!res.ok) {
    throw new Error(`Failed to download font ${style}: ${res.status} ${res.statusText}`);
  }
  const buf = Buffer.from(await res.arrayBuffer());
  await new Promise<void>((resolvePromise, rejectPromise) => {
    writeFileCallback(filePath, buf, (err) => (err ? rejectPromise(err) : resolvePromise()));
  });
}

async function downloadFonts(force = false): Promise<string[]> {
  const outDir = fileURLToPath(new URL(FONTS_DIR, import.meta.url));
  await mkdir(outDir, { recursive: true });
  const downloaded: string[] = [];
  for (const { style, slug } of FONT_STYLES) {
    const fileName = `material-symbols-${slug}.woff2`;
    const filePath = resolve(outDir, fileName);
    let exists = false;
    if (!force) {
      try {
        await stat(filePath);
        exists = true;
      } catch {
        exists = false;
      }
    }
    if (force || !exists) {
      await downloadFont(style, slug, outDir);
      downloaded.push(fileName);
    }
  }
  return downloaded;
}

try {
  const force = process.env.FORCE_MATERIAL_SYMBOLS_UPDATE === "1";
  console.log(`[material-symbols] Starting update${force ? " (force)" : ""}...`);

  const outDir = fileURLToPath(new URL(GENERATED_DIR, import.meta.url));
  await mkdir(outDir, { recursive: true });
  const metaPath = resolve(outDir, META_FILE);

  let previousMeta: MetaFile | null = null;
  try {
    const raw = await readFile(metaPath, "utf8");
    previousMeta = JSON.parse(raw) as MetaFile;
  } catch {
    // ignore
  }

  console.log("[material-symbols] Fetching upstream commit metadata...");
  const commitSha = await fetchLatestCommitSha();
  if (commitSha)
    console.log(`[material-symbols] Latest upstream commit (variablefont path): ${commitSha}`);
  console.log("[material-symbols] Fetching upstream codepoints...");
  const { entries, hash } = await fetchCodepoints();
  console.log(`[material-symbols] Upstream codepoints hash: ${hash}`);

  const changedCommit =
    commitSha && previousMeta?.commitSha && previousMeta.commitSha !== commitSha;
  const changedHash = !previousMeta || previousMeta.codepointsHash !== hash;

  if (!force && previousMeta && !changedHash && !changedCommit) {
    console.log("[material-symbols] Codepoints & commit unchanged. Skipping regeneration.");
  } else {
    console.log(
      `[material-symbols] Codepoints changed$${!previousMeta ? " (no previous meta)" : ""}. Generating outputs...`,
    );
    const meta: MetaFile = {
      codepointsHash: hash,
      commitSha: commitSha ?? previousMeta?.commitSha,
      updatedAt: new Date().toISOString(),
    };
    await writeOutputs(entries, meta);
    console.log("[material-symbols] Generated codepoints.ts, codepoints.css & meta.json");
  }

  console.log("[material-symbols] Ensuring variable font files (outlined, rounded, sharp)...");
  const fontFiles = await downloadFonts(force);
  if (fontFiles.length) {
    console.log(`[material-symbols] Downloaded fonts: ${fontFiles.join(", ")}`);
  } else {
    console.log("[material-symbols] All font files already present.");
  }
  console.log("[material-symbols] Update complete.");
} catch (err) {
  console.error(err);
  process.exitCode = 1;
}
